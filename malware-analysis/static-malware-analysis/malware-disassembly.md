# Malware Disassembly

Static analysis also includes the dismantling of a given executable into binary format to study its functionalities and features. This process helps identify the language used for programming the malware, look for APIs that reveal its function, and  retrieve other information. Based on the reconstructed assembly code, you can inspect the program logic and recognize its threat potential. This process uses uses debugging tools such as **IDA Pro**, **OllyDbg**, and **Ghidra**.

**IDA** as a disassemble, IDA explores binary programs, for which the source code might not be available, to create maps of their execution. The primary purpose of a disassemble is to display the instructions actually executed by the processor in a symbolic representation called “assembly language”. However, in real life, things are not always simple. Hostile code usually does not cooperate with analyst. Viruses, worms, and Trojans are often armored and obfuscated; as such more powerful tools are required. The debugger in IDA complements the static analysis capabilities of the disassembler. By allowing an analyst to single-step through the code being investigated, the debugger often bypasses the obfuscation. It helps obtain data that the more powerful static disassembler will be able to process in depth.

**OllyDbg** is a debugger that emphasizes binary code analysis, which is useful when source code is unavailable. It traces registers, recognizes procedures, API calls switches, tables, constants, and strings, and locates routines from object files and libraries.

There is a new debugging option, “Set permanent breakpoints on system calls”. When active, it requests OllyDbg to set breakpoints on KERNEL32.UnhandledExceptionFilter(), NTDLL.KiUserExceptionDispatcher(), NTDLL.ZwContinue(), and NTDLL.NtQueryInformationProcess().

**Ghidra** is a software reverse engineering (SRE) framework that includes a suite of full-featured, high-end software analysis tools that enable users to analyze compiled code on a variety of platforms including Windows, MacOS, and Linux. It’s capabilities include disassembly, assembly, decompilation, debugging, emulation, graphing, and scripting. Ghidra supports a wide variety of processor instruction sets and executable formats and can be run in both user-interactive and automated modes. Analysts can also develop their own Ghidra plug-in components and/or scripts using the exposed API. In addition there are numerous ways to extend Ghidra such as new processors, loaders/exporters, automated analyzers, and new visualizations.

***

## IDA

In IDA, could reveal the **Text View, Hex View**, and **Pseudocode View** to help better understanding of the file and information.

* **Structures** tab to view the structure of the file.
* **Enums** tab to view the **Windows Enum** results.

> Press **TAB** button to extend the debugger to more advanced such as use **Pseudocode View**

{% embed url="https://hex-rays.com/ida-pro" %}

To create a graph, copy **qwingraph.exe** in the IDA folder and paste it in IDA installation location.

> Navigate to **View,** choose **Graph**, and click **Flow Chart**
>
> Navigate to **View,** choose **Graph**, and click **Function Calls**

***

## OllyDBG

### Display Log Details

After choose the malware who want to do analysis, choose **View** menu and click **Log** submenu.

Displaying the log details. The Log data displays the program entry point and its calls to known functions.

### Display Executable Modules

Choose **View** menu and click **Executable modules** submenu. Displaying all executable modules. Double click any module to view the complete information of the selected module. Choose 77450000 module, the result may different.

This will redirect to the **CPU – Main Thread**

### Display Memory Mappings

Choose **View** menu and click **Memory** submenu, displaying all memory mappings.

### Displaying All Threads

Choose **View** menu and click **Threads** submenu, displaying all threads.



{% embed url="https://www.ollydbg.de/" %}

***

## Ghidra

The first time import the file will be provided with  **Import Result Summary** to analyze the file.

Wait the file a minute to complete the analysis, after it done, the assembly code of the application appears along with the decompiler.

* **Symbol Tree -> Imports** node: view the DLL files&#x20;
* &#x20;**Program Tree -> Headers** node: jump to the header function
* Double click the **.rdata** node to view the **rdata** function

{% embed url="https://ghidra-sre.org/" %}

***

## Other tools

* Radare2
* WinDbg
* ProcDump
